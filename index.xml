<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>M-Cosmosss</title>
        <link>https://cosmos.red/</link>
        <description>Recent content on M-Cosmosss</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Mon, 13 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cosmos.red/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Innodb 是如何实现 RR 并解决幻读的</title>
        <link>https://cosmos.red/p/innodb-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-rr-%E5%B9%B6%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E7%9A%84/</link>
        <pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://cosmos.red/p/innodb-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-rr-%E5%B9%B6%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E7%9A%84/</guid>
        <description>&lt;img src="https://cosmos.red/p/innodb-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-rr-%E5%B9%B6%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E7%9A%84/c.jpg" alt="Featured image of post Innodb 是如何实现 RR 并解决幻读的" /&gt;&lt;p&gt;pixiv：92080599&lt;/p&gt;
&lt;h1 id=&#34;innodb-是如何解决脏读幻读的&#34;&gt;Innodb 是如何解决脏读、幻读的&lt;/h1&gt;
&lt;h2 id=&#34;幻读&#34;&gt;幻读&lt;/h2&gt;
&lt;p&gt;幻读比较容易与不可重复读搞混，先看看他们的定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不可重复读：在当前事务多次读时，读到因其他事务提交而前后不一致的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;幻读：在同一事务中，相同查询条件的多次查询读取的数据总量不一致&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;提出并解决这些事务问题，都是为了保证在单一事务中不受其他事务的影响。&lt;/p&gt;
&lt;p&gt;解决不可重复读是为了保证，在本事务中 SELECT 得到的结果不会被其他事务影响而改变。一种解决思路是，只需要对 SELECT 的结果行加锁即可。&lt;/p&gt;
&lt;p&gt;但在此之外还会有其他的干扰情况：就算锁住了查找结果，相同的 SELECT 语句仍然可能出现不一样的结果。因为其他事务的 INSERT 操作可能会插入满足之前 SELECT 条件的新数据行。尽管原 SELECT 语句的行数据保证不变，但再次查找就可能多出了几行，如同幻觉一般。这就是与不可重复读不同的另一种事务问题，幻读。&lt;/p&gt;
&lt;h2 id=&#34;可重复读-repeatable-read&#34;&gt;可重复读 Repeatable Read&lt;/h2&gt;
&lt;p&gt;显然，可重复读针对的就是『不可重复读』问题，也是 Innodb 默认的隔离级别&lt;/p&gt;
&lt;p&gt;其实可以通过一个最简单的例子整体思考下事务的目的以及问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事务 T1 查找结果为行 A ，然后事务 T2 想更新行 A 中的数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果要解决『不可重复读』，那么有两种解决思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;直接阻止 T2 的操作。&lt;/p&gt;
&lt;p&gt;在『串行化』隔离级别中，事务中的查找操作也会上锁，因此有着最好的隔离性。在『串行化』以外的隔离级别，也可以使用 &lt;strong&gt;select &amp;hellip; for update / lock in share mode&lt;/strong&gt; 手动对查找操作上锁。但缺点也显而易见，这么做会导致并发性能极差。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在不阻止 T2 操作的情况下，有没有方法阻止『不可重复读』？&lt;/p&gt;
&lt;p&gt;有。其实可以关注到，『不可重复读』要求事务多次读到的数据不变，而不是该数据本身不能变。如果为数据建立快照，就可以同时满足『不变』与『修改』。这种思路可以极大提高并发性能，但尽管符合了『可重复读』的要求，但读到的非实时数据也会成为一个隐患，尤其是在对数据实时性要求高的场合&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个例子主要表明：在实现事务隔离的情况下，也可以用一定的妥协来换取性能。毕竟『串行化』的实现最简单也最安全，但并发性能需求在大多数场合中，比保证数据的绝对实时性更重要。因此多版本并发控制 MVCC 应运而生&lt;/p&gt;
&lt;h2 id=&#34;多版本并发控制-mvcc&#34;&gt;多版本并发控制 MVCC&lt;/h2&gt;
&lt;p&gt;MVCC 就是 Innodb 对于通过为数据建立快照思路的具体实现。由于事务是可以并发的，同一时间自然可能遇到多组事务间需要解决冲突，所以需要的也就是 MVCC 本身：多版本并发控制&lt;/p&gt;
&lt;p&gt;MVCC 不仅用在 RR 级别解决『不可重复读』与『幻读』，也在 READ COMMITED 读已提交级别中解决了『脏读』问题&lt;/p&gt;
&lt;h3 id=&#34;实现&#34;&gt;实现&lt;/h3&gt;
&lt;p&gt;MVCC 有不止一种实现，这里介绍的是 Innodb 的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;每个事务在开启时都会获得一个递增的事务版本 id，记录了每个事务开启的先后顺序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MVCC 为表创建两个隐藏列，&lt;code&gt;trx_id&lt;/code&gt; 与 &lt;code&gt;roll_pointer&lt;/code&gt; .前者记录了本行数据最新被创建/修改的事务 id，后者是由 undo log 实现的回滚指针，指向该行的上一个历史版本，形成链表串联成该行完整的历史快照&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;read-view 一致性视图：第一次读时会记录下这些数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;trx_ids：当前未提交的所有事务 id 组成的数组&lt;/li&gt;
&lt;li&gt;up_limit_id（min）：trx_ids 中的最小值&lt;/li&gt;
&lt;li&gt;low_limit_id（max）：当前所有事务版本 id 的最大值+1，也就是未来下一个出现的事务 id&lt;/li&gt;
&lt;li&gt;creator_trx_id：本事务的 id （也查到称为 current_trx_id 的，暂时没求证）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 RR 隔离级别下，read-view 在整个事务生命期间都不会更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在事务期间的查询操作，会进行以下检查：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若 &lt;code&gt;trx_id&lt;/code&gt; &amp;lt; min，说明该行的最晚修改时间一定在本事务开启前，是可见数据&lt;/li&gt;
&lt;li&gt;若 &lt;code&gt;trx_id&lt;/code&gt; &amp;gt; max，说明该行的最晚修改时间一定在本事务开启后，不可见，需要通过 &lt;code&gt;roll_pointer&lt;/code&gt; 找到可见的历史版本&lt;/li&gt;
&lt;li&gt;若 min &amp;lt; &lt;code&gt;trx_id&lt;/code&gt; &amp;lt; max，则无法直接判断，需要在 trx_ids 数组中进行二分查找，确认&lt;code&gt;trx_id&lt;/code&gt; 是否存在其中：若存在则说明是不可见版本。反之亦然&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Tips：其实第一、二步的判断只是为了提高性能，不然每次查询操作都需要在 trx_ids 数组中二分查找&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mvcc-与-脏读&#34;&gt;MVCC 与 脏读&lt;/h3&gt;
&lt;p&gt;前文也提到了，MVCC 也在 RC 隔离级别中解决了『脏读』，其实与 MVCC 在 RR 中解决『幻读』的机制很相似，唯一的区别是 read-view 一致性视图变为了：在事务中每次 SELECT 操作中都会重新生成一次，推演一下其影响就能明白， RC 隔离级别为什么不存在脏读但是『不可重复读』了&lt;/p&gt;
&lt;h2 id=&#34;快照读与当前读&#34;&gt;快照读与当前读&lt;/h2&gt;
&lt;p&gt;在启用了 MVCC 后，事务中查找操作得到的数据不再一定是最新值，要确保得到最新值只能使用  &lt;code&gt;SELECT ... FOR UPDATE / LOCK IN SHARE MODE&lt;/code&gt; ，因此 MVCC 让读操作分为了『快照读』与『当前读』两种，在《InnoDB 技术内幕》中称为『一致性锁定/非锁定读』&lt;/p&gt;
&lt;p&gt;MVCC 可以确保在 RR 隔离级别下，『快照读』中不会出现幻读现象，但『快照读』和『当前读』在事务里同时出现时，就可能出现幻读&lt;/p&gt;
&lt;p&gt;INSERT 与 UPDATE 实际上也算是一种『当前读』，重点在于这两个操作会使事务脱离『快照』，接触到『当前』，这点很重要，后文中还会提起&lt;/p&gt;
&lt;h2 id=&#34;间隙锁与临键锁&#34;&gt;间隙锁与临键锁&lt;/h2&gt;
&lt;p&gt;简单重复一下概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;间隙锁：对索引的一段区间范围上锁，使得无法在对应区间插入新行，区间为左开右开&lt;/li&gt;
&lt;li&gt;临键锁：对索引的一段区间范围上锁，区间为左开右闭。其本质实现就是间隙锁+行锁，作用也相当于就是将间隙锁与行锁组合在一起使用，从而做到『左开右闭』。临键锁是『当前读』时的默认加锁单位，因此主要会讨论临键锁，但基本可以将其视为间隙锁+行锁即可&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;间隙锁和临键锁只存在于 RR 隔离级别下，因为其本身只能用来解决幻读，在其他隔离级别也无意义&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;间隙锁的出现是为了实现 &lt;code&gt;阻止一个范围内出现新行&lt;/code&gt; ，而之所以有这个需求是为了在『当前读』的情况下解决『幻读』。&lt;/p&gt;
&lt;p&gt;间隙锁之间不冲突，因此两个事务可以同时申请同一个范围的间隙锁，间隙锁的唯一目的就是阻止范围内的插入操作&lt;/p&gt;
&lt;p&gt;临键锁的加锁原则比较复杂和底层，网上也有很多对着源码分析的文章，因此我打算仅记录归纳后的总结。示例表 test ：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id 主键&lt;/th&gt;
&lt;th&gt;uid 普通索引&lt;/th&gt;
&lt;th&gt;gid 唯一索引&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;非唯一索引&#34;&gt;非唯一索引&lt;/h3&gt;
&lt;p&gt;也就是普通索引，被『当前读』显式查找的结果，及其前后间隙都会被临键锁锁定&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意！UPDATE INSERT DELETE 等『写操作』本身也需要『当前读』，因此它们也会导致临键锁锁定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;T1&lt;/th&gt;
&lt;th&gt;T2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;select * from test where uid = 5 for update;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;insert into test values (4,2,2);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;临键锁锁定区间为 uid的 (1,10)，也就是查找结果&lt;code&gt;(2,5,5)&lt;/code&gt;再加上它上下的间隙，是开区间。T2 事务被阻塞&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以思考一个问题，在此处场景中，select 并不是范围而是等值查询，只有可能查到 uid = 5的行，就算接下来 insert uid 为1~4，6~10之间的行，也不可能发生幻读，那为什么不只给&lt;code&gt;(2,5,5)&lt;/code&gt; 这一行上行锁呢？&lt;/p&gt;
&lt;p&gt;首先是由于此处为普通索引，没有唯一性，因此还可以插入 uid = 5 的行，这就会导致幻读。其次这仍然导致了本不应该受影响的 uid 范围被禁止 insert，为什么不设计另一种机制，仅禁止 uid = 5 行的 insert？ 关于这个问题网上鲜有讨论（也可能是我孤陋寡闻=。=），目前我看到的有一定信服力的解释是：原因和索引使用的 B+ Tree 结构有关，只能实现到这种地步。如果有了解这个问题的欢迎评论指正 Orz&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;T1&lt;/th&gt;
&lt;th&gt;T2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;select * from test where uid &amp;gt;= 5 for update;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;insert into test values (4,6,2);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;临键锁锁定区间为 uid的 (1,+supernum) 。supernum 是数据库维护的最大的值&lt;/p&gt;
&lt;h3 id=&#34;唯一索引&#34;&gt;唯一索引&lt;/h3&gt;
&lt;p&gt;唯一索引最大的区别在于等值查找场景时，由于能确保唯一性所以可以降级到行锁即可，而普通索引的话只能维持在临键锁&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;其实关于临键锁的锁区间范围规律，归根到底还是为了阻止幻读的可能而锁住可能产生幻读的空间。我认为不必过多关注其实现，因为实际锁住的范围一定是&lt;strong&gt;大于等于&lt;/strong&gt;理论上需要锁住的范围，只要清楚这点，就能从另一种逆推的思维也能得到相近的结果。&lt;/p&gt;
&lt;p&gt;而之所以是&lt;strong&gt;大于等于&lt;/strong&gt;而不是&lt;strong&gt;等于&lt;/strong&gt;，一方面是由于实现手段的不够理想（如普通索引的等值查询会锁住额外的范围），另一方面则是 Innodb 本身也存在 bug，丁奇老师在《Mysql 实战45讲》中就提出过一个临键锁范围的 bug，直到 8.0.18 版本才被修复。所以也不能一味地相信源码实现的正确性。&lt;/p&gt;
&lt;h2 id=&#34;结语qa&#34;&gt;结语＆QA&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;于是，&lt;code&gt;InnoDB 在 RR 下不会产生幻读&lt;/code&gt; 这句话是正确的吗？这个问题很难直接给出答案&lt;/p&gt;
&lt;p&gt;倘若在事务中没有产生『当前读』，那在 MVCC 机制的作用下，确实不可能会出现幻读；但『当前读』出现后，先『快照读』再『当前读』就可能产生幻读；倘若只使用『当前读』，那临键锁机制也可以确保阻止幻读，但实际上这种情况的并发性能已经下降到『串行化』级别了&lt;/p&gt;
&lt;p&gt;只能说在 RR 下，InnoDB 解决了仅『快照读』与仅『当前读』情况下的『幻读』问题，但混合使用时则没有解决&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RR 隔离级别下，read-view 一致性视图只在事务的第一次 select 操作后才建立&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;T1&lt;/th&gt;
&lt;th&gt;T2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;update test set uid = 2 where id = 1;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;update test set uid = 3 where id =1;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;select * from test where id = 1;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;那有没有可能发生如上表，最终 T1 查找结果为 （1，3，1）而不是预期的（1，2，1）类似幻读的情况？&lt;/p&gt;
&lt;p&gt;A：不可能，因为 update 操作也是『当前写』，会上锁，T2 事务的更新操作无法执行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考文章&#34;&gt;参考文章&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tech.meituan.com/2014/08/20/innodb-lock.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Innodb中的事务隔离级别和锁的关系&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://time.geekbang.org/column/intro/139&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL 实战45讲&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文中如有错误，欢迎在评论区指出 Orzzzz&lt;/p&gt;
</description>
        </item>
        <item>
        <title>《Mysql 技术内幕》阅读笔记</title>
        <link>https://cosmos.red/p/mysql-%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://cosmos.red/p/mysql-%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;img src="https://cosmos.red/p/mysql-%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/b.jpg" alt="Featured image of post 《Mysql 技术内幕》阅读笔记" /&gt;&lt;h1 id=&#34;mysql&#34;&gt;Mysql&lt;/h1&gt;
&lt;h2 id=&#34;p2&#34;&gt;P2&lt;/h2&gt;
&lt;h3 id=&#34;threads&#34;&gt;Threads&lt;/h3&gt;
&lt;h4 id=&#34;master-thread&#34;&gt;Master Thread&lt;/h4&gt;
&lt;p&gt;包含多个循环（主循环，background，flush，suspend）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日志写入磁盘&lt;/li&gt;
&lt;li&gt;合并 Insert Buffer 到磁盘&lt;/li&gt;
&lt;li&gt;刷新脏页&lt;/li&gt;
&lt;li&gt;删除无用 Undo 页&lt;/li&gt;
&lt;li&gt;1.2.x 版本前，刷新脏页等 IO 速度硬编码，版本后添加 innodb_io_capacity 代表磁盘速度，此变量影响刷新页的速度&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;io-thread&#34;&gt;IO Thread&lt;/h4&gt;
&lt;p&gt;InnoDB 使用 Async IO ，IO Thread 负责这些异步 IO 请求的回调&lt;/p&gt;
&lt;h4 id=&#34;purge-thread&#34;&gt;Purge Thread&lt;/h4&gt;
&lt;p&gt;1.1 版本后，回收 Undo 页由主线程转为此线程负责&lt;/p&gt;
&lt;h4 id=&#34;page-cleaner-thread&#34;&gt;Page Cleaner Thread&lt;/h4&gt;
&lt;p&gt;1.2.x 版本后，刷新脏页由主线程转为此线程负责&lt;/p&gt;
&lt;h3 id=&#34;缓冲池&#34;&gt;缓冲池&lt;/h3&gt;
&lt;h4 id=&#34;页类型&#34;&gt;页类型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;索引页、数据页、undo 页、插入缓冲 (insert buffer)、自适应哈希索引(adaptive hash index&amp;gt;、InnoDB 存储的锁信息（lockinfo)、数据字典信息(data dictionary) 等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;http://pic.cosmos.red//image-20210717031742053.png&#34; &gt;
		&lt;img src=&#34;http://pic.cosmos.red//image-20210717031742053.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;innodb_buffer_pool_instances&#34;&gt;innodb_buffer_pool_instances&lt;/h4&gt;
&lt;p&gt;设定缓冲池数量&lt;/p&gt;
&lt;h3 id=&#34;池内存管理&#34;&gt;池内存管理&lt;/h3&gt;
&lt;h4 id=&#34;改动过的-lru-算法&#34;&gt;改动过的 LRU 算法&lt;/h4&gt;
&lt;p&gt;LRU 列表中加入了 midpoint 位置：最新访问的页并不是直接放入到 LRU 列表的首部，而是放入到 LRU 列表的 midpoint 位置（默认配置下，该位置在 LRU 列表长度的 5/8 处）&lt;/p&gt;
&lt;p&gt;若直接将读取到的页放入到 LRU 的首部，那么某些 SQL 操作可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。常见的这类操作为索引或数据的扫描操作。这类操作需要访问表中的许多页，甚至是全部的页，而这些页通常来说又仅在这次查询操作中需要，并不是活跃的热点数据。如果页被放入 LRU 列表的首部，那么非常可能将所需要的热点数据页从 LRU 列表中移除，而在下一次需要读取该页时，InnoDB 存储引擎需要再次访问磁盘。&lt;/p&gt;
&lt;p&gt;innodb_old_blocks_time 控制的 Old 链表头部页面的转移策略。该 Page 需要在 Old 链表停留超过该时间，之后再次被访问，才会移动到 Young 链表。这么操作是避免 Young 链表被那些只在 innodb_old_blocks_time 时间间隔内频繁访问，之后就不被访问的页面塞满，从而有效的保护 Young 链表。&lt;/p&gt;
&lt;h4 id=&#34;缓冲命中率&#34;&gt;缓冲命中率&lt;/h4&gt;
&lt;p&gt;Buffer pool hit rate，表示缓冲池的命中率，这个例子中为 100%，说明缓冲池运行状态非常良好。通常该值不应该小于 95%。若发生 Buffer pool hit rate 的值小于 95% 这种情况，用户需要观察是否是由于全表扫描引起的 LRU 列表被污染的问题。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;http://pic.cosmos.red//image-20210719035257307.png&#34; &gt;
		&lt;img src=&#34;http://pic.cosmos.red//image-20210719035257307.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;checkpoint&#34;&gt;Checkpoint&lt;/h3&gt;
&lt;p&gt;将缓冲池中的脏页刷回到磁盘&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缩短数据库的恢复时间&lt;/li&gt;
&lt;li&gt;缓冲池不够用时，将脏页刷新到磁盘&lt;/li&gt;
&lt;li&gt;重做日志不可用时，刷新脏页。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;sharp-checkpoint&#34;&gt;Sharp Checkpoint&lt;/h4&gt;
&lt;p&gt;一次性将 buffer pool 当中的所有脏页刷新到磁盘数据文件&lt;/p&gt;
&lt;h4 id=&#34;fuzzy-checkpointin&#34;&gt;Fuzzy checkpointin&lt;/h4&gt;
&lt;p&gt;一个后台进程，定期刷新 buffer pool 当中的脏页&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Master Thread Checkpoint：主线程定期异步地刷新一部分脏页&lt;/li&gt;
&lt;li&gt;FLUSH_LRU_LIST Checkpoint：LRU 中需保证的可用页不足时移除部分尾端页，其中的脏页被刷新&lt;/li&gt;
&lt;li&gt;Async/Sync Flush Checkpoint：redo log 不可用时&lt;/li&gt;
&lt;li&gt;Dirty Page too much Checkpoint：脏页过多，由参数 innodb_max_dirty_pages_pct 控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;插入缓冲-insert-buffer&#34;&gt;插入缓冲 Insert Buffer&lt;/h3&gt;
&lt;p&gt;聚集索引基本为递增，而非聚集索引大多为非顺序，插入操作需要随机写入会影响性能，因此插入缓冲在插入或更新操作，先判断插入的非聚集索引页在缓冲池中，则直接插入；若不在，则先放入到一个 Insert Buffer 对象中。再以一定的频率和情况进行 Insert Buffer 和辅助索引页子节点的 merge（合并）操作，大大的提升了非聚集索引的插入性能。&lt;/p&gt;
&lt;h4 id=&#34;实现&#34;&gt;实现&lt;/h4&gt;
&lt;p&gt;B+ Tree&lt;/p&gt;
&lt;h4 id=&#34;使用条件&#34;&gt;使用条件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;索引是辅助索引：聚集索引本来就是顺序&lt;/li&gt;
&lt;li&gt;索引不是唯一：如果是唯一索引，在插入时，需要查找辅助索引树，判断该记录是否存在以确保唯一性，查找过程就是随机读的过程，因此插入缓冲就没意义了&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;merge-场合&#34;&gt;Merge 场合&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;辅助索引页被读取到缓冲池时，也就是常规 SELECT 使用了辅助索引时&lt;/li&gt;
&lt;li&gt;Insert Buffer Bitmap 页追踪到该辅助索引页已无可用空间时&lt;/li&gt;
&lt;li&gt;Master Thread 定期合并&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;change-buffer&#34;&gt;change buffer&lt;/h4&gt;
&lt;p&gt;InnoDB 从1.0.x版本开始引入了 Change Buffer，可将其视为Insert Buffer 的升级。从这个版本开始，InnoDB存储引擎可以对 DML操作——INSERT、DELETE、UPDATE都进行缓冲，他们分别是: Insert Buffer、Delete Buffer、Purge buffer&lt;/p&gt;
&lt;h3 id=&#34;doublewrite&#34;&gt;Doublewrite&lt;/h3&gt;
&lt;h4 id=&#34;partial-write&#34;&gt;partial write&lt;/h4&gt;
&lt;p&gt;InnoDB 的 page size 默认是 16KB，而操作系统与物理磁盘的一个 block size 更小，这会导致在极端情况下 (断电 / os crash) 对磁盘的页写入只有部分成功，即无法确保页写入操作的原子性&lt;/p&gt;
&lt;h4 id=&#34;实现-1&#34;&gt;实现&lt;/h4&gt;
&lt;p&gt;doublewrite 是 Innodb 磁盘表空间内部分配的一片缓冲区，一般 double write 包含 128 个页，对于 pagesize 为 16k 的页，总共 2MB。Innodb 在磁盘写入时先将页写入 doublewrite 缓冲区，然后再将其从缓冲区写入真正的表内存储位置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写 double write buffer 本身失败，那么这些数据不会被写到磁盘，InnoDB 此时会从磁盘载入原始的数据，然后通过 InnoDB 的事务日志来计算出正确的数据，重新写入到 double write buffer&lt;/li&gt;
&lt;li&gt;写 double write buffer 本身成功，写数据到磁盘失败，Innodb 存储引擎可以从共享表空间的 double write 中找到该页的副本，将其复制到表空间文件，再应用 redo log，就完成了恢复过程&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;redo-log-能否恢复&#34;&gt;redo log 能否恢复&lt;/h4&gt;
&lt;p&gt;纯物理日志实现 redo log 完全不依赖物理页的状态，并且是幂等性的，因此可以恢复 partial write&lt;/p&gt;
&lt;p&gt;而 innoDB 的 redo 采用的是物理逻辑结合型的日志。物理到具体的哪个 page，页内操作是逻辑的。这种方式既实现了物理日志带来的幂等性（以物理页为整体），又拥有逻辑日志带来的轻量性（物理页内修改是逻辑日志）。所以物理页内修改不是幂等的，需要使用 doublewrite 技术来保证写入的成功&lt;/p&gt;
&lt;h4 id=&#34;redo-log-是否需要保护&#34;&gt;redo log 是否需要保护&lt;/h4&gt;
&lt;p&gt;redo 日志的页大小一般设计为 512 Byte，不会出现 partial write&lt;/p&gt;
&lt;h4 id=&#34;others&#34;&gt;others&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;向磁盘上的 doublewrite 缓冲区写入时是顺序写入，因此性能影响不大。缓冲区再向各表同步时还是随机写入的&lt;/li&gt;
&lt;li&gt;若文件系统本身支持原子性写入，确保不会发生 partial write 就可以关闭 double write 来避免无意义的性能损失&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;自适应哈希索引&#34;&gt;自适应哈希索引&lt;/h3&gt;
&lt;p&gt;InnoDB 存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引，来提高查询效率。可以关闭该功能但不能强制启用哈希索引&lt;/p&gt;
&lt;h4 id=&#34;自动启用条件&#34;&gt;自动启用条件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;连续查询的条件一样：例如不能交替查询 WHERE a=xxx 和 WHERE a=xxx and b=xxx&lt;/li&gt;
&lt;li&gt;连续用同样的模式访问100次&lt;/li&gt;
&lt;li&gt;页通过该模式访问了N次，其中N=页中记录*1/16 （没看懂）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;异步io--刷新邻接页&#34;&gt;异步IO / 刷新邻接页&lt;/h3&gt;
&lt;p&gt;常规特色也就是异步能避免 IO 阻塞线程；另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO，这样可以提高IOPS的性能&lt;/p&gt;
&lt;p&gt;当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，如果是脏页，那么一起进行刷新。该工作机制在传统机械磁盘下有着显著的优势，但是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可能将不怎么脏的页进行了写人，而该页之后又会很快变成脏页&lt;/li&gt;
&lt;li&gt;固态硬盘有着较高的IOPS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此对于固态硬盘建议不启用此特性&lt;/p&gt;
&lt;h3 id=&#34;启动关闭与恢复&#34;&gt;启动关闭与恢复&lt;/h3&gt;
&lt;h4 id=&#34;innodb_fast-shutdown&#34;&gt;innodb_fast shutdown&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;0表示在MySQL数据库关闭时，InnoDB需要完成所有的full purge和 mergeinsert buffer，并且将所有的脏页刷新回磁盘。这需要一些时间，有时甚至需要几个小时来完成。如果在进行InnoDB升级时，必须将这个参数调为0，然后再关闭数据库。&lt;/li&gt;
&lt;li&gt;1是参数innodb_fast_shutdown 的默认值，表示不需要完成上述的full purge和merge insert buffer操作，但是在缓冲池中的一些数据脏页还是会刷新回磁盘。2表示不完成full purge和 merge insert buffer操作，也不将缓冲池中的数据脏页写回磁盘，而是将日志都写入日志文件。这样不会有任何事务的丢失，但是下次MySQL数据库启动时，会进行恢复操作（recovery)。&lt;/li&gt;
&lt;li&gt;2表示不完成full purge和 merge insert buffer操作，也不将缓冲池中的数据脏页写回磁盘，而是将日志都写入日志文件。这样不会有任何事务的丢失，但是下次MySQL数据库启动时，会进行恢复操作（recovery)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;innodb_force_recovery&#34;&gt;innodb_force_recovery&lt;/h4&gt;
&lt;p&gt;默认为0，可设置为1~6&lt;/p&gt;
&lt;p&gt;代表当发生需要恢复时，进行所有的恢复操作，当不能进行有效恢复时，如数据页发生了corruption，MySQL数据库可能发生宕机（crash)，并把错误写入错误日志中去&lt;/p&gt;
&lt;h2 id=&#34;p3&#34;&gt;P3&lt;/h2&gt;
&lt;h3 id=&#34;mysql参数&#34;&gt;mysql参数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;static 静态变量：无法在实例生命周期内修改&lt;/li&gt;
&lt;li&gt;dynamic 动态参数：分为session级与global级&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;日志文件&#34;&gt;日志文件&lt;/h3&gt;
&lt;h4 id=&#34;error-log&#34;&gt;error log&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;错误日志文件对MySQL的启动、运行、关闭过程进行了记录，也包含一些警告与正确的信息&lt;/li&gt;
&lt;li&gt;文件路径定位：SHOW VARIABLES LIKE&amp;rsquo;log_error&#39;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;slow-log&#34;&gt;slow log&lt;/h4&gt;
&lt;p&gt;可以在 MySQL启动时设一个阈值，将运行时间大于（不包含等于）该值的所有SQL语句都记录到慢查询日志文件中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数：long_query_time。默认值为10，代表10秒。&lt;/li&gt;
&lt;li&gt;参数：log_slow_queries，是否启用 slow log 。默认不开启，需要手动设为 ON&lt;/li&gt;
&lt;li&gt;参数：log_queries_not_using_indexes，是否启用检测未使用索引的语句&lt;/li&gt;
&lt;li&gt;参数：log_throttle_queries_not_using_indexes，表示每分钟允许记录到 slow log 的且未使用索引的SQL语句次数。默认为0，表示无限制。此参数作用是防止过于频繁触发未使用索引检测，导致 slow log 过快无意义增长&lt;/li&gt;
&lt;li&gt;mysqldumpslow 命令辅助分析慢查询日志&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;InnoDB 额外统计了 SQL 执行中逻辑读取（包含物理读取与缓冲池读取）与物理读取的次数，观察它们的比例可以辅助判断是否需要优化&lt;/p&gt;
&lt;h3 id=&#34;查询日志&#34;&gt;查询日志&lt;/h3&gt;
&lt;p&gt;查询日志记录了所有对MySQL数据库请求的信息，无论这些请求是否得到了正确的执行。默认文件名为:主机名.log&lt;/p&gt;
&lt;h3 id=&#34;bin-log&#34;&gt;bin log&lt;/h3&gt;
&lt;p&gt;二进制日志记录了对 MySQL 数据厍执行更改的所有操作以及时间等信息，但是不包括 SELECT 和 SHOW 这类操作，因为这类操作对数据本身并没有修改&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若有 UPDATE 操作未对数据库产生变化，也会被记录在 bin log 中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要有以下作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;恢复（recovery）：某些数据的恢复需要二进制日志，例如在一个数据库全备文件恢复后，可以通过二进制日志进行 poing-in-time 的恢复&lt;/li&gt;
&lt;li&gt;复制（replication）：其原理与恢复类似，通过复制和执行二进制日志，使两台数据库实时同步&lt;/li&gt;
&lt;li&gt;审计（audit）：判断有无 sql 注入攻击&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;缓存&#34;&gt;缓存&lt;/h4&gt;
&lt;p&gt;使用事务的引擎中，未提交的二进制日志会先写入缓存中（基于session）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;binlog_cache_size：决定该缓存的大小&lt;/li&gt;
&lt;li&gt;缓存超出限制大小时会创建临时文件&lt;/li&gt;
&lt;li&gt;binlog_cache_use、binlog_cache_disk_use分别代表使用缓存与使用临时文件缓存二进制日志的次数，观察这俩变量可以得知缓存限制是否过小&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;同步&#34;&gt;同步&lt;/h4&gt;
&lt;p&gt;sync_binlog&lt;/p&gt;
&lt;p&gt;占坑&lt;/p&gt;
&lt;h4 id=&#34;格式&#34;&gt;格式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Statement-based：记录 SQL 语句。容量小，恢复数据快，具有可读性；但存在一些无法确保恢复数据一致的情景，不能使用该模式&lt;/li&gt;
&lt;li&gt;Row-based：记录每一行变化的二进制原始数据。安全性高，需要更少的锁因此性能更好；容量更大&lt;/li&gt;
&lt;li&gt;MIXED：以上两种混合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细：&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/26977878&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL binlog 日志的格式&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;redo-log&#34;&gt;redo log&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;二进制日志会记录所有与MySQL数据库有关的日志记录，包括InnoDB、MylSAM、Heap等其他存储引擎的日志。而InnoDB存储引擎的重做日志只记录有关该存储引擎本身的事务日志&lt;/li&gt;
&lt;li&gt;其次，记录的内容不同，无论用户将二进制日志文件记录的格式设为STATEMENT还是ROW，又或者是MIXED，其记录的都是关于一个事务的具体操作内容，即该日志是逻辑日志。而InnoDB存储引擎的重做日志文件记录的是关于每个页(Page）的更改的物理情况。&lt;/li&gt;
&lt;li&gt;此外，写入的时间也不同，二进制日志文件仅在事务提交前进行提交，即只写磁盘一次，不论这时该事务多大。而在事务进行的过程中，却不断有重做日志条目（redocntry）被写入到重做日志文件中。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;上面提过，redo log写入单位为512字节，能保证写入的原子性因此不需要 double write 机制保护&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体还是等事务部分细说，占坑&lt;/p&gt;
&lt;h2 id=&#34;p4-表&#34;&gt;P4 表&lt;/h2&gt;
&lt;h3 id=&#34;外键约束&#34;&gt;外键约束&lt;/h3&gt;
&lt;p&gt;外键 (FOREIGN KEY) 用于建立两个表数据中列的链接，从而维护数据一致性。被引用的表称为为父表，引用的表为子表，通常子表引用父表的主键建立约束：子表的外键指向父表主键&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认引擎不支持外键&lt;/li&gt;
&lt;li&gt;外键与其指向的主键类型必须相同&lt;/li&gt;
&lt;li&gt;子表插入一行时，若父表的主键中不存在与该行外键一致的值则不能插入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;外键约束有四种子表操作来实现数据一致性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CASCADE (级联)：父表更新或删除一行时，子表中外键与其主键一致的所有行也更新或删除&lt;/li&gt;
&lt;li&gt;RESTRICT (约束)：父表更新或删除一行时，如果子表中存在外键与其主键一致的行，则不允许并报错&lt;/li&gt;
&lt;li&gt;SET NULL：父表更新或删除一行时，子表中外键与其主键一致的所有行将外键设为 NULL（该列需要允许为 NULL）&lt;/li&gt;
&lt;li&gt;NO ACTION：与 RESTRICT 一致&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;外键约束对于确保数据一致性有着很好的作用，但是对性能有显著影响。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不使用外键牺牲了数据库中数据的一致性，但是却能够减少数据库的负载；&lt;/li&gt;
&lt;li&gt;模拟外键将一部分工作移到了数据库之外，我们可能需要放弃一部分一致性以获得更高的可用性，但是为了这部分可用性，我们会付出更多的研发与维护成本，也增加了与数据库之间的网络通信次数；&lt;/li&gt;
&lt;li&gt;使用外键保证了数据库中数据的一致性，也将全部的计算任务全部交给了数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;转自：&lt;a class=&#34;link&#34; href=&#34;https://draveness.me/whys-the-design-database-foreign-key/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;为什么数据库不应该使用外键&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;p5-索引与算法&#34;&gt;P5 索引与算法&lt;/h2&gt;
&lt;h3 id=&#34;b-tree&#34;&gt;B+ tree&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB中一般为2-4层，以适应磁盘随机读取开销较大的特性，在查询时降低随机 IO 次数&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;插入&#34;&gt;插入&lt;/h4&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;http://pic.cosmos.red//image-20210823100442159.png&#34; &gt;
		&lt;img src=&#34;http://pic.cosmos.red//image-20210823100442159.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以此图为例，插入70&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;拆分：&lt;figure 
	&gt;
	&lt;a href=&#34;http://pic.cosmos.red//image-20210823100516595.png&#34; &gt;
		&lt;img src=&#34;http://pic.cosmos.red//image-20210823100516595.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;旋转：当左右兄弟节点未满时，优先使用旋转提高效率&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;http://pic.cosmos.red//image-20210823100624552.png&#34; &gt;
		&lt;img src=&#34;http://pic.cosmos.red//image-20210823100624552.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;索引&#34;&gt;索引&lt;/h3&gt;
&lt;p&gt;采用B+ 树结构，叶子节点由双向链表连接&lt;/p&gt;
&lt;h4 id=&#34;创建索引&#34;&gt;创建索引&lt;/h4&gt;
&lt;p&gt;ALTER TABLE tbl_name&lt;/p&gt;
&lt;p&gt;CREATE [UNIQUE] INDEX index_name [index_type] ON tbl_name&lt;/p&gt;
&lt;h4 id=&#34;聚焦索引&#34;&gt;聚焦索引&lt;/h4&gt;
&lt;p&gt;每张表仅有一个，以主键为索引，叶子节点（数据页）存放的是完整行数据&lt;/p&gt;
&lt;h5 id=&#34;主键&#34;&gt;主键&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;不可修改（？）：因为主键的第二个作用是让其他表的外键引用自己，从而实现关系结构。一旦某个表的主键发生了变化，就会导致所有引用了该表的数据必须全部修改外键。很多Web应用的数据库并不是强约束（仅仅引用主键但并没有设置外键约束），修改主键会导致数据完整性直接被破坏&lt;/li&gt;
&lt;li&gt;业务无关：为满足不可修改原则，主键不能与业务有关联&lt;/li&gt;
&lt;li&gt;不宜过大：辅助索引的值为主键，因为主键的大小会影响辅助索引大小&lt;/li&gt;
&lt;li&gt;推荐使用自增：因为innodb是B+ 树结构，自增主键导致新增行时是高性能的顺序写入，同时避免了B+ 树的拆分。也因此对范围查询拥有高性能&lt;/li&gt;
&lt;li&gt;自增主键也会遇到自增锁的性能问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;辅助索引非聚焦索引&#34;&gt;辅助索引/非聚焦索引&lt;/h4&gt;
&lt;p&gt;叶子节点只存放主键，因此需要根据主键在聚焦索引里二次查询才能得到完整行内容，这个过程称为回表&lt;/p&gt;
&lt;h4 id=&#34;联合索引&#34;&gt;联合索引&lt;/h4&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;http://pic.cosmos.red//image-20210824170734902.png&#34; &gt;
		&lt;img src=&#34;http://pic.cosmos.red//image-20210824170734902.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对多个列组合起来的索引，如 (a,b) 索引将先按 a 再按 b 排序。因此针对 a 或者 a&amp;amp;&amp;amp;b 的条件查询都可以使用该索引，但是 b 条件不行，因为此联合索引没有按 b 的顺序&lt;/p&gt;
&lt;p&gt;也因为多列索引都以排序这个特性，可以免去部分范围查询的二次排序&lt;/p&gt;
&lt;h4 id=&#34;覆盖索引&#34;&gt;覆盖索引&lt;/h4&gt;
&lt;p&gt;当只在辅助索引（一般即为联合索引）中就能得到查询的记录时，即可省去回表这步&lt;/p&gt;
&lt;p&gt;使用统计（COUNT）时也会优先使用可行的联合索引，因为单节点小，同页节点多查询更快&lt;/p&gt;
&lt;h4 id=&#34;fast-index-creation&#34;&gt;Fast Index Creation&lt;/h4&gt;
&lt;p&gt;在5.5版本前，索引的添加或删除需要创建并导入原表数据到一张新表，因此需要宕机很长的时间&lt;/p&gt;
&lt;p&gt;5.5版本后有了 FIC 对创建索引的表加上 S 锁，不再需要创建新表因此速度大大提高，此技术仅适用于辅助索引。但这个过程中对表只能读不能写&lt;/p&gt;
&lt;h4 id=&#34;cardinality&#34;&gt;Cardinality&lt;/h4&gt;
&lt;p&gt;代表索引中不重复记录的比例，即索引的『选择性』。如性别列中只会有F,M两个选项，就只有50%的选择性&lt;/p&gt;
&lt;p&gt;当 Cardinality 值过低代表该索引低选择性，为其建立索引的意义较低&lt;/p&gt;
&lt;p&gt;Cardinality 的统计是由引擎层实现的。InnoDB 中 Cardinality 值是随机对8个叶子节点采样统计，因此表未改动的情况下该值也可能不同。统计 Cardinality 可能会产生较大的性能损耗，因此不应随意进行&lt;/p&gt;
&lt;h4 id=&#34;mrr--multi-range-read&#34;&gt;MRR / Multi-Range Read&lt;/h4&gt;
&lt;p&gt;在进行如范围查询这种需要批量回表操作的查询时，若不做任何优化则回表查询会是随机读取，而 MRR 的作用就是在回表前，对这一批查询根据主键进行排序再回表，这样回表就变成了较为顺序的读取，从而提高性能&lt;/p&gt;
&lt;h4 id=&#34;icp--索引条件下推优化&#34;&gt;ICP / 索引条件下推优化&lt;/h4&gt;
&lt;p&gt;开启 ICP 时，使用辅助索引进行条件查询，会在查询辅助索引的同时就判断是否可以进行 WHERE 条件的过滤，过滤掉已经不符合要求的行后再回表。未开启 ICP 则不会有这步过滤，而只会回表取出所有完整行数据再进行过滤。ICP 相当于辅助索引查询时，利用联合索引已经包含多个列信息的特点，提前进行可能的 WHERE 条件筛选，从而减少不必要的回表来提高性能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适用于 InnoDB 和 MyISAM&lt;/li&gt;
&lt;li&gt;显然，只有联合索引才可能在查询时提前过滤&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;启用 ICP 的情况下利用二级索引查找数据的过程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用二级索引查找数据的主键；&lt;/li&gt;
&lt;li&gt;如果二级索引记录的元组里的列出现在 where 条件里，那么对元组进行过滤；&lt;/li&gt;
&lt;li&gt;对索引元组的主键回表读取完整的行记录；&lt;/li&gt;
&lt;li&gt;利用 where 语句的剩余条件对行记录进行过滤；&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;全文索引&#34;&gt;全文索引&lt;/h4&gt;
&lt;p&gt;InnoDB 使用 full inverted index 形式的倒排索引，记录了每个单词出现在哪个文档以及在其中的位置&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;http://pic.cosmos.red//image-20210825174421628.png&#34; &gt;
		&lt;img src=&#34;http://pic.cosmos.red//image-20210825174421628.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;http://pic.cosmos.red//image-20210825174429861.png&#34; &gt;
		&lt;img src=&#34;http://pic.cosmos.red//image-20210825174429861.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h5 id=&#34;用法&#34;&gt;用法&amp;hellip;&lt;/h5&gt;
&lt;h2 id=&#34;p6-锁&#34;&gt;P6 锁&lt;/h2&gt;
&lt;h3 id=&#34;lock--latch&#34;&gt;lock / latch&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;http://pic.cosmos.red//image-20210825182952229.png&#34; &gt;
		&lt;img src=&#34;http://pic.cosmos.red//image-20210825182952229.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;基本锁&#34;&gt;基本锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;共享锁 (S Lock)：允许事务读&lt;/li&gt;
&lt;li&gt;排他锁 (X Lock)：允许事务删除或更新&lt;/li&gt;
&lt;li&gt;这里的锁粒度在行级&lt;/li&gt;
&lt;li&gt;在申请行锁时，需要先申请表锁（意向锁）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查询操作使用了索引时申请的是行锁，而查询没有索引的列只能全表扫描，因此只能升级为表锁&lt;/p&gt;
&lt;h3 id=&#34;意向锁&#34;&gt;意向锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;分为 意向共享锁 (IS Lock) 和 意向排他锁 (IX Lock)&lt;/li&gt;
&lt;li&gt;意向锁的粒度是表级，其他与基本锁一致&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作用在于提高锁的效率：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当向一个表添加表级 X 锁的时候&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果没有意向锁的话，则需要遍历所有整个表判断是否有行锁的存在，以免发生冲突&lt;/li&gt;
&lt;li&gt;如果有了意向锁，只需要判断该意向锁与即将添加的表级锁是否兼容即可。因为意向锁的存在代表了，有行级锁的存在或者即将有行级锁的存在。因而无需遍历整个表，即可获取结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;转自：&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/51513268/answer/147733422&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;知乎：InnoDB 的意向锁有什么作用？&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;一致性锁定--非锁定读&#34;&gt;一致性锁定 / 非锁定读&lt;/h3&gt;
&lt;p&gt;一致性非锁定读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 MVCC （多版本并发控制）为数据建立多版本快照，当读取的行有 X 锁时，会读取快照中的历史数据&lt;/li&gt;
&lt;li&gt;基于 undo log 实现，因此本身不会有额外的开销&lt;/li&gt;
&lt;li&gt;因为快照中的都是历史数据不会被修改，因此不需要上锁，从而大大提高并发性能&lt;/li&gt;
&lt;li&gt;是否启用要看事务隔离级别&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体还是在 MVCC 部分讲&lt;/p&gt;
&lt;p&gt;一致性锁定读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某些情况需要显式地对读取操作加锁来保证数据一致性&lt;/li&gt;
&lt;li&gt;SELECT&amp;hellip;FOR UPDATE：对读取的行加上 X 锁&lt;/li&gt;
&lt;li&gt;SELECT&amp;hellip;LOCK IN SHARE MODE：对读取行加 S 锁&lt;/li&gt;
&lt;li&gt;必须在事务中才生效&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;自增锁&#34;&gt;自增锁&lt;/h3&gt;
&lt;p&gt;对含有自增属性的表进行插入操作时，为了解决并发问题而存在的特殊表锁&lt;/p&gt;
&lt;p&gt;根据参数 innodb_autoinc_lock_mode 共有三种运作模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传统模式：向包含了自增属性列的表中插入数据时，获得 AUTO-INC 自增锁，在语句执行结束后释放，而不需要等到事务结束。确保自增列是顺序的，但同时只能执行一条插入语句&lt;/li&gt;
&lt;li&gt;连续模式：如果插入语句能够提前确定插入的数据量，就不使用自增锁（也有说是立刻获取再释放），而是使用更轻量的互斥锁完成自增操作，不必等待 sql 语句执行完才能进行下一次插入&lt;/li&gt;
&lt;li&gt;交叉模式：所有插入都不使用自增锁，而是轻量互斥锁，从而可以近似并发地执行。但因此相同自增值并不连续，因为 &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; 的值分配会在多个 &lt;code&gt;INSERT&lt;/code&gt; 语句中来回交叉的执行，在并发的情况下无法保证数据一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为交叉模式的特性，当 bin log 格式为 statement 时，由于其记录的是 sql 语句，在主从同步时无法确保数据一致。所以当使用交叉模式时，要么设置为 row 格式，要么确保自己永远不会用到 bin log&lt;/p&gt;
&lt;h3 id=&#34;外键的锁&#34;&gt;外键的锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Innodb 会自动给外键列建立索引，从而避免外键约束检查时用到表锁&lt;/li&gt;
&lt;li&gt;外键值的插入或更新需要查询父表，不使用一致性非锁定读，而是申请 S 锁来避免数据不一致&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;行锁记录锁间隙锁临键锁&#34;&gt;行锁：记录锁、间隙锁、临键锁&lt;/h3&gt;
&lt;h4 id=&#34;记录锁-record-lock&#34;&gt;记录锁 Record Lock&lt;/h4&gt;
&lt;p&gt;单行记录的锁&lt;/p&gt;
&lt;h4 id=&#34;间隙锁-gap-lock&#34;&gt;间隙锁 Gap Lock&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;对索引的一个范围内锁定&lt;/li&gt;
&lt;li&gt;范围两边都是开区间，如 between 10 and 20 锁定范围是(10，20)&lt;/li&gt;
&lt;li&gt;只在 RR 可重复读隔离级别有效&lt;/li&gt;
&lt;li&gt;间隙锁之间不存在冲突关系，只用于阻止在锁定的范围内插入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;丁奇老师的总结&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原则 1：加锁的基本单位是 next-key lock&lt;/p&gt;
&lt;p&gt;原则 2：查找过程中访问到的对象才会加锁&lt;/p&gt;
&lt;p&gt;优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁&lt;/p&gt;
&lt;p&gt;优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁&lt;/p&gt;
&lt;p&gt;一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止（目前已经在 Mysql 8.0.18 中修复）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;临键锁-next-key-lock&#34;&gt;临键锁 Next-Key Lock&lt;/h4&gt;
&lt;p&gt;结合了记录锁与间隙锁而成，锁定范围为&lt;strong&gt;左开右闭&lt;/strong&gt;区间内的索引&lt;/p&gt;
&lt;h4 id=&#34;临键锁如何解决幻读&#34;&gt;临键锁如何解决幻读&lt;/h4&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cosmos.red/p/innodb-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-rr-%E5%B9%B6%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E7%9A%84/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Innodb 是如何实现 RR 并解决幻读的&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Hello World</title>
        <link>https://cosmos.red/p/hello-world/</link>
        <pubDate>Thu, 20 May 2021 00:00:00 +0000</pubDate>
        
        <guid>https://cosmos.red/p/hello-world/</guid>
        <description>&lt;img src="https://cosmos.red/p/hello-world/a.png" alt="Featured image of post Hello World" /&gt;&lt;h1 id=&#34;now-loading&#34;&gt;Now Loading!!!&lt;/h1&gt;
</description>
        </item>
        
    </channel>
</rss>
